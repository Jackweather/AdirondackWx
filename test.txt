import os
import requests
from datetime import datetime, timedelta
import xarray as xr
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
from matplotlib.colors import ListedColormap, BoundaryNorm
from PIL import Image

# Directories
base_url = "https://nomads.ncep.noaa.gov/cgi-bin/filter_hrrr_2d.pl"
output_dir = "Hrrr"
grib_dir = os.path.join(output_dir, "grib_files")
png_dir = os.path.join(output_dir, "pngs")
gif_dir = os.path.join(output_dir, "gifs")
os.makedirs(grib_dir, exist_ok=True)
os.makedirs(png_dir, exist_ok=True)
os.makedirs(gif_dir, exist_ok=True)

# Get the current UTC date and time and subtract 6 hours
current_utc_time = datetime.utcnow() - timedelta(hours=6)
date_str = current_utc_time.strftime("%Y%m%d")
hour_str = str(current_utc_time.hour // 6 * 6).zfill(2)  # Adjust to nearest 6-hour slot

# Reflectivity variable and colormap
variable_refc = "REFC"
colors = [
    "#FFFFFF", "#04e9e7", "#019ff4", "#0300f4", "#02fd02",
    "#01c501", "#008e00", "#fdf802", "#e5bc00", "#fd9500",
    "#fd0000", "#d40000", "#bc0000", "#f800fd", "#9854c6", "#fdfdfd"
]
bounds = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75]
cmap = ListedColormap(colors)
norm = BoundaryNorm(bounds, cmap.N)

# Function to download GRIB files
def download_file(hour_str, step):
    file_name = f"hrrr.t{hour_str}z.wrfsfcf{step:02d}.grib2"
    file_path = os.path.join(grib_dir, file_name)
    url_refc = (f"{base_url}?dir=%2Fhrrr.{date_str}%2Fconus&file={file_name}"
                f"&var_{variable_refc}=on&lev_entire_atmosphere=on")
    response = requests.get(url_refc, stream=True)
    if response.status_code == 200:
        with open(file_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=1024):
                if chunk:
                    f.write(chunk)
        print(f"Downloaded {file_name}")
        return file_path
    else:
        print(f"Failed to download {file_name} (Status Code: {response.status_code})")
        return None

# Function to generate PNG from GRIB file
def generate_png(file_path, step):
    ds = xr.open_dataset(file_path, engine="cfgrib")
    refc = ds['refc'].where((ds['refc'] >= 0) & (ds['refc'] <= 75))
    lats = ds['latitude']
    lons = ds['longitude']
    fig = plt.figure(figsize=(12, 9))
    ax = plt.axes(projection=ccrs.LambertConformal())
    ax.set_extent([-95, -75, 25, 37], crs=ccrs.PlateCarree())
    contour = ax.contourf(
        lons, lats, refc.squeeze(),
        levels=bounds, cmap=cmap, norm=norm, transform=ccrs.PlateCarree()
    )
    ax.coastlines(resolution='10m')
    ax.add_feature(cfeature.STATES.with_scale('10m'), linewidth=0.5)
    ax.set_title(f"HRRR Composite Reflectivity\nValid: {ds.time.values}", fontsize=16)
    cbar = plt.colorbar(contour, ax=ax, orientation='vertical', pad=0.02, shrink=0.8)
    cbar.set_label('Reflectivity (dBZ)')
    png_path = os.path.join(png_dir, f"reflectivity_{step:02d}.png")
    plt.tight_layout()
    plt.savefig(png_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Generated PNG: {png_path}")
    return png_path

# Function to create GIF from PNGs
def create_gif(png_files, gif_path):
    images = [Image.open(png) for png in png_files]
    images[0].save(
        gif_path, save_all=True, append_images=images[1:], duration=500, loop=0
    )
    print(f"Generated GIF: {gif_path}")

# Main process
grib_files = []
# Download all GRIB files first
for step in range(0, 49):  # Loop through forecast steps (00 to 48 hours)
    grib_file = download_file(hour_str, step)
    if grib_file:
        grib_files.append(grib_file)

# Generate PNGs after all files have been downloaded
png_files = []
for i, grib_file in enumerate(grib_files):
    png_file = generate_png(grib_file, i)
    png_files.append(png_file)

# Create GIF from PNGs if files were successfully generated
if png_files:
    gif_path = os.path.join(gif_dir, "reflectivity_animation.gif")
    create_gif(png_files, gif_path)

print("All download and GIF creation tasks complete!")
